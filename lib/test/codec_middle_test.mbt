// Code generated by scripts/gen_codec_tests.py. DO NOT EDIT.

struct MiddleDecoded {
  id : Int
  values : Array[Int]
  packed_values : Array[Int]
  label : String
  data : Bytes
  nested : (Int64, Bool, String)?
  status : UInt
  tags : Array[String]
}

struct MiddleCase {
  b64 : String
  id : Int
  values : Array[Int]
  packed_values : Array[Int]
  label : String
  data : Bytes
  nested : (Int64, Bool, String)?
  status : UInt
  tags : Array[String]
}

fn decode_middle_nested(bytes : Bytes) -> (Int64, Bool, String) raise {
  let reader = @protobuf.BytesReader::from_bytes(bytes) as &@protobuf.Reader
  let mut count = 0L
  let mut flag = false
  let mut note = ""
  while true {
    let tag_result = try { reader |> @protobuf.read_tag() } catch { _ => None } noraise { v => Some(v) }
    match tag_result {
      Some((tag, wire_type)) =>
        match tag {
          1 => count = reader |> @protobuf.read_int64()
          2 => flag = reader |> @protobuf.read_bool()
          3 => note = reader |> @protobuf.read_string()
          _ => reader |> @protobuf.read_unknown(wire_type)
        }
      None => break
    }
  }
  (count, flag, note)
}

fn decode_middle(b64 : String) -> MiddleDecoded raise {
  let bytes = @protobuf.base64_decode(b64)
  let reader = @protobuf.BytesReader::from_bytes(bytes) as &@protobuf.Reader
  let mut id = 0
  let values : Array[Int] = []
  let packed_values : Array[Int] = []
  let mut label = ""
  let mut data = b""
  let mut nested : (Int64, Bool, String)? = None
  let mut status = 0U
  let tags : Array[String] = []
  while true {
    let tag_result = try { reader |> @protobuf.read_tag() } catch { _ => None } noraise { v => Some(v) }
    match tag_result {
      Some((tag, wire_type)) =>
        match tag {
          1 => id = reader |> @protobuf.read_int32()
          2 => values.push(reader |> @protobuf.read_int32())
          3 => {
            let packed = reader
              |> @protobuf.read_packed(
                fn(r) { r |> @protobuf.read_sint32() },
                None,
              )
            for value in packed {
              packed_values.push(value.0)
            }
          }
          4 => label = reader |> @protobuf.read_string()
          5 => data = reader |> @protobuf.read_bytes()
          6 => nested = reader |> @protobuf.read_bytes() |> decode_middle_nested() |> Some
          7 => status = (reader |> @protobuf.read_enum()).0
          8 => tags.push(reader |> @protobuf.read_string())
          _ => reader |> @protobuf.read_unknown(wire_type)
        }
      None => break
    }
  }
  { id, values, packed_values, label, data, nested, status, tags }
}

fn encode_middle_nested(value : (Int64, Bool, String)) -> Bytes raise {
  let (count, flag, note) = value
  let writer = @buffer.new()
  if count != 0L {
    writer |> @protobuf.write_tag((1U, 0U))
    writer |> @protobuf.write_int64(count)
  }
  if flag {
    writer |> @protobuf.write_tag((2U, 0U))
    writer |> @protobuf.write_bool(flag)
  }
  if note != "" {
    writer |> @protobuf.write_tag((3U, 2U))
    writer |> @protobuf.write_string(note)
  }
  writer.to_bytes()
}

fn encode_middle(case : MiddleCase) -> String raise {
  let writer = @buffer.new()
  if case.id != 0 {
    writer |> @protobuf.write_tag((1U, 0U))
    writer |> @protobuf.write_int32(case.id)
  }
  for value in case.values {
    writer |> @protobuf.write_tag((2U, 0U))
    writer |> @protobuf.write_int32(value)
  }
  if case.packed_values.length() > 0 {
    let packed_writer = @buffer.new()
    for value in case.packed_values {
      packed_writer |> @protobuf.write_sint32(value)
    }
    writer |> @protobuf.write_tag((3U, 2U))
    writer |> @protobuf.write_bytes(packed_writer.to_bytes())
  }
  if case.label != "" {
    writer |> @protobuf.write_tag((4U, 2U))
    writer |> @protobuf.write_string(case.label)
  }
  if case.data.length() > 0 {
    writer |> @protobuf.write_tag((5U, 2U))
    writer |> @protobuf.write_bytes(case.data)
  }
  if case.nested is Some(value) {
    writer |> @protobuf.write_tag((6U, 2U))
    writer |> @protobuf.write_bytes(encode_middle_nested(value))
  }
  if case.status != 0U {
    writer |> @protobuf.write_tag((7U, 0U))
    writer |> @protobuf.write_enum(@protobuf.Enum(case.status))
  }
  for tag in case.tags {
    writer |> @protobuf.write_tag((8U, 2U))
    writer |> @protobuf.write_string(tag)
  }
  writer.to_bytes() |> @protobuf.base64_encode
}

///|
test "middle/messages" {
  let cases : Array[MiddleCase] = [
    {
      b64: "CAEQARACEAMaAwEAAiIFYWxwaGEqAgECMgsIZBABGgVub3RlMTgBQgF4QgF5",
      id: 1,
      values: [1, 2, 3],
      packed_values: [-1, 0, 1],
      label: "alpha",
      data: b"\x01\x02",
      nested: Some((100L, true, "note1")),
      status: 1U,
      tags: ["x", "y"],
    },
    {
      b64: "CCoQZBDIARoDgIkPIgRiZXRhKgH/Mg0IqUYQARoGbmVzdGVkOAJCB3RhZy1vbmU=",
      id: 42,
      values: [100, 200],
      packed_values: [123456],
      label: "beta",
      data: b"\xff",
      nested: Some((9001L, true, "nested")),
      status: 2U,
      tags: ["tag-one"],
    },
    {
      b64: "CAcaCv////8P/v///w8iBWdhbW1hKgQA/xAgOAE=",
      id: 7,
      values: [],
      packed_values: [-2147483648, 2147483647],
      label: "gamma",
      data: b"\x00\xff\x10\x20",
      nested: None,
      status: 1U,
      tags: [],
    },
    {
      b64: "COgHEP///////////wEQABABIgVkZWx0YSoDECAwMgcIARABGgFuOAJCAnQxQgJ0MkICdDM=",
      id: 1000,
      values: [-1, 0, 1],
      packed_values: [],
      label: "delta",
      data: b"\x10\x20\x30",
      nested: Some((1L, true, "n")),
      status: 2U,
      tags: ["t1", "t2", "t3"],
    },
    {
      b64: "CP////8HEP////8HGgbxwAHywAEiB2Vwc2lsb24qAQAyEgj///////////8BEAEaA25lZzgBQgRlZGdl",
      id: 2147483647,
      values: [2147483647],
      packed_values: [-12345, 12345],
      label: "epsilon",
      data: b"\x00",
      nested: Some((-1L, true, "neg")),
      status: 1U,
      tags: ["edge"],
    },
    {
      b64: "CAIQABAFGgEAIgR6ZXRhKgYBAgMEBQYyFAiVmu86EAEaC2xvbmdlciBub3RlOAJCAWFCAWJCAWNCAWQ=",
      id: 2,
      values: [0, 5],
      packed_values: [0],
      label: "zeta",
      data: b"\x01\x02\x03\x04\x05\x06",
      nested: Some((123456789L, true, "longer note")),
      status: 2U,
      tags: ["a", "b", "c", "d"],
    },
  ]
  for case in cases {
    let decoded = decode_middle(case.b64)
    assert_eq(decoded.id, case.id)
    assert_eq(decoded.values, case.values)
    assert_eq(decoded.packed_values, case.packed_values)
    assert_eq(decoded.label, case.label)
    assert_eq(decoded.data, case.data)
    assert_eq(decoded.nested, case.nested)
    assert_eq(decoded.status, case.status)
    assert_eq(decoded.tags, case.tags)
    assert_eq(encode_middle(case), case.b64)
  }
}
