// Code generated by scripts/gen_codec_tests.py. DO NOT EDIT.

struct DifficultDecoded {
  big : UInt64
  zigzag : Int
  ratio : Double
  scores : Array[Double]
  items : Array[(String, Bytes, UInt64)]
  counts : Array[(String, Int)]
  choice_text : String?
  choice_number : Int?
  payload : Bytes
}

struct DifficultCase {
  b64 : String
  big : UInt64
  zigzag : Int
  ratio : Double
  scores : Array[Double]
  items : Array[(String, Bytes, UInt64)]
  counts : Array[(String, Int)]
  choice_text : String?
  choice_number : Int?
  payload : Bytes
}

fn decode_item(bytes : Bytes) -> (String, Bytes, UInt64) raise {
  let reader = @protobuf.BytesReader::from_bytes(bytes) as &@protobuf.Reader
  let mut name = ""
  let mut raw = b""
  let mut code = 0UL
  while true {
    let tag_result = try { reader |> @protobuf.read_tag() } catch { _ => None } noraise { v => Some(v) }
    match tag_result {
      Some((tag, wire_type)) =>
        match tag {
          1 => name = reader |> @protobuf.read_string()
          2 => raw = reader |> @protobuf.read_bytes()
          3 => code = reader |> @protobuf.read_fixed64()
          _ => reader |> @protobuf.read_unknown(wire_type)
        }
      None => break
    }
  }
  (name, raw, code)
}

fn decode_count(bytes : Bytes) -> (String, Int) raise {
  let reader = @protobuf.BytesReader::from_bytes(bytes) as &@protobuf.Reader
  let mut key = ""
  let mut value = 0
  while true {
    let tag_result = try { reader |> @protobuf.read_tag() } catch { _ => None } noraise { v => Some(v) }
    match tag_result {
      Some((tag, wire_type)) =>
        match tag {
          1 => key = reader |> @protobuf.read_string()
          2 => value = reader |> @protobuf.read_int32()
          _ => reader |> @protobuf.read_unknown(wire_type)
        }
      None => break
    }
  }
  (key, value)
}

fn decode_difficult(b64 : String) -> DifficultDecoded raise {
  let bytes = @protobuf.base64_decode(b64)
  let reader = @protobuf.BytesReader::from_bytes(bytes) as &@protobuf.Reader
  let mut big = 0UL
  let mut zigzag = 0
  let mut ratio = 0.0
  let scores : Array[Double] = []
  let items : Array[(String, Bytes, UInt64)] = []
  let counts : Array[(String, Int)] = []
  let mut choice_text : String? = None
  let mut choice_number : Int? = None
  let mut payload = b""
  while true {
    let tag_result = try { reader |> @protobuf.read_tag() } catch { _ => None } noraise { v => Some(v) }
    match tag_result {
      Some((tag, wire_type)) =>
        match tag {
          1 => big = reader |> @protobuf.read_uint64()
          2 => zigzag = (reader |> @protobuf.read_sint32()).0
          3 => ratio = reader |> @protobuf.read_double()
          4 => {
            let packed = reader
              |> @protobuf.read_packed(
                fn(r) { r |> @protobuf.read_double() },
                Some(8U),
              )
            for score in packed {
              scores.push(score)
            }
          }
          5 => items.push(reader |> @protobuf.read_bytes() |> decode_item())
          6 => counts.push(reader |> @protobuf.read_bytes() |> decode_count())
          7 => choice_text = reader |> @protobuf.read_string() |> Some
          8 => choice_number = reader |> @protobuf.read_int32() |> Some
          9 => payload = reader |> @protobuf.read_bytes()
          _ => reader |> @protobuf.read_unknown(wire_type)
        }
      None => break
    }
  }
  { big, zigzag, ratio, scores, items, counts, choice_text, choice_number, payload }
}

fn encode_item(item : (String, Bytes, UInt64)) -> Bytes raise {
  let (name, raw, code) = item
  let writer = @buffer.new()
  if name != "" {
    writer |> @protobuf.write_tag((1U, 2U))
    writer |> @protobuf.write_string(name)
  }
  if raw.length() > 0 {
    writer |> @protobuf.write_tag((2U, 2U))
    writer |> @protobuf.write_bytes(raw)
  }
  if code != 0UL {
    writer |> @protobuf.write_tag((3U, 1U))
    writer |> @protobuf.write_fixed64(code)
  }
  writer.to_bytes()
}

fn encode_count(entry : (String, Int)) -> Bytes raise {
  let (key, value) = entry
  let writer = @buffer.new()
  if key != "" {
    writer |> @protobuf.write_tag((1U, 2U))
    writer |> @protobuf.write_string(key)
  }
  if value != 0 {
    writer |> @protobuf.write_tag((2U, 0U))
    writer |> @protobuf.write_int32(value)
  }
  writer.to_bytes()
}

fn encode_difficult(case : DifficultCase) -> String raise {
  let writer = @buffer.new()
  if case.big != 0UL {
    writer |> @protobuf.write_tag((1U, 0U))
    writer |> @protobuf.write_uint64(case.big)
  }
  if case.zigzag != 0 {
    writer |> @protobuf.write_tag((2U, 0U))
    writer |> @protobuf.write_sint32(case.zigzag)
  }
  if case.ratio != 0.0 {
    writer |> @protobuf.write_tag((3U, 1U))
    writer |> @protobuf.write_double(case.ratio)
  }
  if case.scores.length() > 0 {
    let packed_writer = @buffer.new()
    for score in case.scores {
      packed_writer |> @protobuf.write_double(score)
    }
    writer |> @protobuf.write_tag((4U, 2U))
    writer |> @protobuf.write_bytes(packed_writer.to_bytes())
  }
  for item in case.items {
    writer |> @protobuf.write_tag((5U, 2U))
    writer |> @protobuf.write_bytes(encode_item(item))
  }
  for entry in case.counts {
    writer |> @protobuf.write_tag((6U, 2U))
    writer |> @protobuf.write_bytes(encode_count(entry))
  }
  if case.choice_text is Some(value) {
    writer |> @protobuf.write_tag((7U, 2U))
    writer |> @protobuf.write_string(value)
  }
  if case.choice_number is Some(value) {
    writer |> @protobuf.write_tag((8U, 0U))
    writer |> @protobuf.write_int32(value)
  }
  if case.payload.length() > 0 {
    writer |> @protobuf.write_tag((9U, 2U))
    writer |> @protobuf.write_bytes(case.payload)
  }
  writer.to_bytes() |> @protobuf.base64_encode
}

///|
test "difficult/messages" {
  let cases : Array[DifficultCase] = [
    {
      b64: "CAEQARkAAAAAAAD4PyIQAAAAAAAA9D8AAAAAAAAEwCoPCgFhEgEBGQEAAAAAAAAAMgUKAWEQATIFCgFiEAI6BWhlbGxvSgIAAQ==",
      big: 1UL,
      zigzag: -1,
      ratio: 1.5,
      scores: [1.25, -2.5],
      items: [("a", b"\x01", 1UL)],
      counts: [("a", 1), ("b", 2)],
      choice_text: Some("hello"),
      choice_number: None,
      payload: b"\x00\x01",
    },
    {
      b64: "CP///////////wEQgIkPGQAAAAAAAAzAIhAAAAAAAAAAAAAAAAAA4FhAKhQKBWZpcnN0EgL/ABnw3ryaeFY0EjILCgNtYXgQ/////wdAKkoB/w==",
      big: 18446744073709551615UL,
      zigzag: 123456,
      ratio: -3.5,
      scores: [0, 99.5],
      items: [("first", b"\xff\x00", 1311768467463790320UL)],
      counts: [("max", 2147483647)],
      choice_text: None,
      choice_number: Some(42),
      payload: b"\xff",
    },
    {
      b64: "CICAgICAgICAgAEQ/////w8ZAAAAAAAAAEAqAwoBeCoQCgF5EgIQIBnnAwAAAAAAADIOCgF4EP///////////wEyBQoBeRAHOgV3b3JsZEoDECAw",
      big: 9223372036854775808UL,
      zigzag: -2147483648,
      ratio: 2,
      scores: [],
      items: [("x", b"", 0UL), ("y", b"\x10\x20", 999UL)],
      counts: [("x", -1), ("y", 7)],
      choice_text: Some("world"),
      choice_number: None,
      payload: b"\x10\x20\x30",
    },
    {
      b64: "CCoQAhkAAAAAAADAPyIYAAAAAAAA8L8AAAAAAAAAwAAAAAAAAAjAQABKAQE=",
      big: 42UL,
      zigzag: 1,
      ratio: 0.125,
      scores: [-1, -2, -3],
      items: [],
      counts: [],
      choice_text: None,
      choice_number: Some(0),
      payload: b"\x01",
    },
    {
      b64: "COcHEM0PGW6GG/D5IQlAIhD8qfHSTWJQPwAAAAAAQI9AKhQKA2JpZxIEAAECAxn//////////zIJCgVhbHBoYRBkMgkKBGJldGEQyAEyCgoFZ2FtbWEQrAI6C2Nob2ljZSB0ZXh0SgQA/xAg",
      big: 999UL,
      zigzag: -999,
      ratio: 3.1415899999999999,
      scores: [0.001, 1000],
      items: [("big", b"\x00\x01\x02\x03", 18446744073709551615UL)],
      counts: [("alpha", 100), ("beta", 200), ("gamma", 300)],
      choice_text: Some("choice text"),
      choice_number: None,
      payload: b"\x00\xff\x10\x20",
    },
    {
      b64: "CJWCpu/HnoSRERDywAEZldYm6AsuET4iEHe+nxov3V5Aarx0kxioiEAqEQoBbRIDAQIDGRXNWwcAAAAAMg4KAWsQgICAgPj/////AUD/////B0oBfw==",
      big: 1234567890123456789UL,
      zigzag: 12345,
      ratio: 1.0000000000000001e-9,
      scores: [123.456, 789.01199999999994],
      items: [("m", b"\x01\x02\x03", 123456789UL)],
      counts: [("k", -2147483648)],
      choice_text: None,
      choice_number: Some(2147483647),
      payload: b"\x7f",
    },
  ]
  for case in cases {
    let decoded = decode_difficult(case.b64)
    assert_eq(decoded.big, case.big)
    assert_eq(decoded.zigzag, case.zigzag)
    assert_eq(decoded.ratio, case.ratio)
    assert_eq(decoded.scores, case.scores)
    assert_eq(decoded.items, case.items)
    assert_eq(decoded.counts, case.counts)
    assert_eq(decoded.choice_text, case.choice_text)
    assert_eq(decoded.choice_number, case.choice_number)
    assert_eq(decoded.payload, case.payload)
    assert_eq(encode_difficult(case), case.b64)
  }
}
